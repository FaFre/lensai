// Autogenerated from Pigeon (v22.3.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

PlatformException _createConnectionError(String channelName) {
  return PlatformException(
    code: 'channel-error',
    message: 'Unable to establish connection on channel: "$channelName".',
  );
}

List<Object?> wrapResponse({Object? result, PlatformException? error, bool empty = false}) {
  if (empty) {
    return <Object?>[];
  }
  if (error == null) {
    return <Object?>[result];
  }
  return <Object?>[error.code, error.message, error.details];
}

/// Indicates what location the tabs should be restored at
enum RestoreLocation {
  /// Restore tabs at the beginning of the tab list
  beginning,
  /// Restore tabs at the end of the tab list
  end,
  /// Restore tabs at a specific index in the tab list
  atIndex,
}

/// An icon resource type.
enum IconType {
  favicon,
  appleTouchIcon,
  fluidIcon,
  imageSrc,
  openGraph,
  twitter,
  microsoftTile,
  tippyTop,
  manifestIcon,
}

/// Supported sizes.
///
/// We are trying to limit the supported sizes in order to optimize our caching strategy.
enum IconSize {
  defaultSize,
  launcher,
  launcherAdaptive,
}

/// The source of an [Icon].
enum IconSource {
  /// This icon was generated.
  generator,
  /// This icon was downloaded.
  download,
  /// This icon was inlined in the document.
  inline,
  /// This icon was loaded from an in-memory cache.
  memory,
  /// This icon was loaded from a disk cache.
  disk,
}

enum CookieSameSiteStatus {
  noRestriction,
  lax,
  strict,
  unspecified,
}

/// Translation options that map to the Gecko Translations Options.
///
/// @property downloadModel If the necessary models should be downloaded on request. If false, then
/// the translation will not complete and throw an exception if the models are not already available.
class TranslationOptions {
  TranslationOptions({
    required this.downloadModel,
  });

  bool downloadModel;

  Object encode() {
    return <Object?>[
      downloadModel,
    ];
  }

  static TranslationOptions decode(Object result) {
    result as List<Object?>;
    return TranslationOptions(
      downloadModel: result[0]! as bool,
    );
  }
}

/// Value type that represents the state of reader mode/view.
class ReaderState {
  ReaderState({
    required this.readerable,
    required this.active,
    required this.checkRequired,
    required this.connectRequired,
    this.baseUrl,
    this.activeUrl,
    this.scrollY,
  });

  /// Whether or not the current page can be transformed to
  /// be displayed in a reader view.
  bool readerable;

  /// Whether or not reader view is active.
  bool active;

  /// Whether or not a readerable check is required for the
  /// current page.
  bool checkRequired;

  /// Whether or not a new connection to the reader view
  /// content script is required.
  bool connectRequired;

  /// The base URL of the reader view extension page.
  String? baseUrl;

  /// The URL of the page currently displayed in reader view.
  String? activeUrl;

  /// The vertical scroll position of the page currently
  /// displayed in reader view.
  int? scrollY;

  Object encode() {
    return <Object?>[
      readerable,
      active,
      checkRequired,
      connectRequired,
      baseUrl,
      activeUrl,
      scrollY,
    ];
  }

  static ReaderState decode(Object result) {
    result as List<Object?>;
    return ReaderState(
      readerable: result[0]! as bool,
      active: result[1]! as bool,
      checkRequired: result[2]! as bool,
      connectRequired: result[3]! as bool,
      baseUrl: result[4] as String?,
      activeUrl: result[5] as String?,
      scrollY: result[6] as int?,
    );
  }
}

/// Details about the last playing media in this tab.
class LastMediaAccessState {
  LastMediaAccessState({
    required this.lastMediaUrl,
    required this.lastMediaAccess,
    required this.mediaSessionActive,
  });

  /// [TabContentState.url] when media started playing.
  /// This is not the URL of the media but of the page when media started.
  /// Defaults to "" (an empty String) if media hasn't started playing.
  /// This value is only updated when media starts playing.
  /// Can be used as a backup to [mediaSessionActive] for knowing the user is still on the same website
  /// on which media was playing before media started playing in another tab.
  String lastMediaUrl;

  /// The last time media started playing in the current web document.
  /// Defaults to [0] if media hasn't started playing.
  /// This value is only updated when media starts playing.
  int lastMediaAccess;

  /// Whether or not the last accessed media is still active.
  /// Can be used as a backup to [lastMediaUrl] on websites which allow media to continue playing
  /// even when the users accesses another page (with another URL) in that same HTML document.
  bool mediaSessionActive;

  Object encode() {
    return <Object?>[
      lastMediaUrl,
      lastMediaAccess,
      mediaSessionActive,
    ];
  }

  static LastMediaAccessState decode(Object result) {
    result as List<Object?>;
    return LastMediaAccessState(
      lastMediaUrl: result[0]! as String,
      lastMediaAccess: result[1]! as int,
      mediaSessionActive: result[2]! as bool,
    );
  }
}

/// Represents a set of history metadata values that uniquely identify a record. Note that
/// when recording observations, the same set of values may or may not cause a new record to be
/// created, depending on the de-bouncing logic of the underlying storage i.e. recording history
/// metadata observations with the exact same values may be combined into a single record.
class HistoryMetadataKey {
  HistoryMetadataKey({
    required this.url,
    this.searchTerm,
    this.referrerUrl,
  });

  /// A url of the page.
  String url;

  /// An optional search term if this record was
  /// created as part of a search by the user.
  String? searchTerm;

  /// An optional url of the parent/referrer if
  /// this record was created in response to a user opening
  /// a page in a new tab.
  String? referrerUrl;

  Object encode() {
    return <Object?>[
      url,
      searchTerm,
      referrerUrl,
    ];
  }

  static HistoryMetadataKey decode(Object result) {
    result as List<Object?>;
    return HistoryMetadataKey(
      url: result[0]! as String,
      searchTerm: result[1] as String?,
      referrerUrl: result[2] as String?,
    );
  }
}

class PackageCategoryValue {
  PackageCategoryValue({
    required this.value,
  });

  int value;

  Object encode() {
    return <Object?>[
      value,
    ];
  }

  static PackageCategoryValue decode(Object result) {
    result as List<Object?>;
    return PackageCategoryValue(
      value: result[0]! as int,
    );
  }
}

/// Describes an external package.
class ExternalPackage {
  ExternalPackage({
    required this.packageId,
    required this.category,
  });

  /// An Android package id.
  String packageId;

  /// A [PackageCategory] as defined by the application.
  PackageCategoryValue category;

  Object encode() {
    return <Object?>[
      packageId,
      category,
    ];
  }

  static ExternalPackage decode(Object result) {
    result as List<Object?>;
    return ExternalPackage(
      packageId: result[0]! as String,
      category: result[1]! as PackageCategoryValue,
    );
  }
}

class LoadUrlFlagsValue {
  LoadUrlFlagsValue({
    required this.value,
  });

  int value;

  Object encode() {
    return <Object?>[
      value,
    ];
  }

  static LoadUrlFlagsValue decode(Object result) {
    result as List<Object?>;
    return LoadUrlFlagsValue(
      value: result[0]! as int,
    );
  }
}

class SourceValue {
  SourceValue({
    required this.id,
    this.caller,
  });

  int id;

  ExternalPackage? caller;

  Object encode() {
    return <Object?>[
      id,
      caller,
    ];
  }

  static SourceValue decode(Object result) {
    result as List<Object?>;
    return SourceValue(
      id: result[0]! as int,
      caller: result[1] as ExternalPackage?,
    );
  }
}

/// A tab that is no longer open and in the list of tabs, but that can be restored (recovered) at
/// any time if it's combined with an [EngineSessionState] to form a [RecoverableTab].
///
/// The values of this data class are usually filled with the values of a [TabSessionState] when
/// getting closed.
class TabState {
  TabState({
    required this.id,
    required this.url,
    this.parentId,
    required this.title,
    required this.searchTerm,
    this.contextId,
    required this.readerState,
    required this.lastAccess,
    required this.createdAt,
    required this.lastMediaAccessState,
    required this.private,
    this.historyMetadata,
    required this.source,
    required this.index,
    required this.hasFormData,
  });

  /// Unique ID identifying this tab.
  String id;

  /// The last URL of this tab.
  String url;

  /// The unique ID of the parent tab if this tab was opened from another tab (e.g. via
  /// the context menu).
  String? parentId;

  /// The last title of this tab (or an empty String).
  String title;

  /// The last used search terms, or an empty string if no
  /// search was executed for this session.
  String searchTerm;

  /// The context ID ("container") this tab used (or null).
  String? contextId;

  /// The last [ReaderState] of the tab.
  ReaderState readerState;

  /// The last time this tab was selected.
  int lastAccess;

  /// Timestamp of the tab's creation.
  int createdAt;

  /// Details about the last time was playing in this tab.
  LastMediaAccessState lastMediaAccessState;

  /// If tab was private.
  bool private;

  /// The last [HistoryMetadataKey] of the tab.
  HistoryMetadataKey? historyMetadata;

  /// The last [IconSource] of the tab.
  SourceValue source;

  /// The index the tab should be restored at.
  int index;

  /// Whether the tab has form data.
  bool hasFormData;

  Object encode() {
    return <Object?>[
      id,
      url,
      parentId,
      title,
      searchTerm,
      contextId,
      readerState,
      lastAccess,
      createdAt,
      lastMediaAccessState,
      private,
      historyMetadata,
      source,
      index,
      hasFormData,
    ];
  }

  static TabState decode(Object result) {
    result as List<Object?>;
    return TabState(
      id: result[0]! as String,
      url: result[1]! as String,
      parentId: result[2] as String?,
      title: result[3]! as String,
      searchTerm: result[4]! as String,
      contextId: result[5] as String?,
      readerState: result[6]! as ReaderState,
      lastAccess: result[7]! as int,
      createdAt: result[8]! as int,
      lastMediaAccessState: result[9]! as LastMediaAccessState,
      private: result[10]! as bool,
      historyMetadata: result[11] as HistoryMetadataKey?,
      source: result[12]! as SourceValue,
      index: result[13]! as int,
      hasFormData: result[14]! as bool,
    );
  }
}

/// A recoverable version of [TabState].
class RecoverableTab {
  RecoverableTab({
    this.engineSessionStateJson,
    required this.state,
  });

  /// The [EngineSessionState] needed for restoring the previous state of this tab.
  String? engineSessionStateJson;

  /// A [TabState] instance containing basic tab state.
  TabState state;

  Object encode() {
    return <Object?>[
      engineSessionStateJson,
      state,
    ];
  }

  static RecoverableTab decode(Object result) {
    result as List<Object?>;
    return RecoverableTab(
      engineSessionStateJson: result[0] as String?,
      state: result[1]! as TabState,
    );
  }
}

/// A restored browser state, read from disk.
class RecoverableBrowserState {
  RecoverableBrowserState({
    required this.tabs,
    this.selectedTabId,
  });

  /// The list of restored tabs.
  List<RecoverableTab?> tabs;

  /// The ID of the selected tab in [tabs]. Or `null` if no selection was restored.
  String? selectedTabId;

  Object encode() {
    return <Object?>[
      tabs,
      selectedTabId,
    ];
  }

  static RecoverableBrowserState decode(Object result) {
    result as List<Object?>;
    return RecoverableBrowserState(
      tabs: (result[0] as List<Object?>?)!.cast<RecoverableTab?>(),
      selectedTabId: result[1] as String?,
    );
  }
}

/// A request to load an [Icon].
class IconRequest {
  IconRequest({
    required this.url,
    required this.size,
    required this.resources,
    this.color,
    required this.isPrivate,
    required this.waitOnNetworkLoad,
  });

  String url;

  IconSize size;

  List<Resource?> resources;

  int? color;

  bool isPrivate;

  bool waitOnNetworkLoad;

  Object encode() {
    return <Object?>[
      url,
      size,
      resources,
      color,
      isPrivate,
      waitOnNetworkLoad,
    ];
  }

  static IconRequest decode(Object result) {
    result as List<Object?>;
    return IconRequest(
      url: result[0]! as String,
      size: result[1]! as IconSize,
      resources: (result[2] as List<Object?>?)!.cast<Resource?>(),
      color: result[3] as int?,
      isPrivate: result[4]! as bool,
      waitOnNetworkLoad: result[5]! as bool,
    );
  }
}

class ResourceSize {
  ResourceSize({
    required this.height,
    required this.width,
  });

  int height;

  int width;

  Object encode() {
    return <Object?>[
      height,
      width,
    ];
  }

  static ResourceSize decode(Object result) {
    result as List<Object?>;
    return ResourceSize(
      height: result[0]! as int,
      width: result[1]! as int,
    );
  }
}

/// An icon resource that can be loaded.
class Resource {
  Resource({
    required this.url,
    required this.type,
    required this.sizes,
    this.mimeType,
    required this.maskable,
  });

  String url;

  IconType type;

  List<ResourceSize?> sizes;

  String? mimeType;

  bool maskable;

  Object encode() {
    return <Object?>[
      url,
      type,
      sizes,
      mimeType,
      maskable,
    ];
  }

  static Resource decode(Object result) {
    result as List<Object?>;
    return Resource(
      url: result[0]! as String,
      type: result[1]! as IconType,
      sizes: (result[2] as List<Object?>?)!.cast<ResourceSize?>(),
      mimeType: result[3] as String?,
      maskable: result[4]! as bool,
    );
  }
}

/// An [Icon] returned by [BrowserIcons] after processing an [IconRequest]
class IconResult {
  IconResult({
    required this.image,
    this.color,
    required this.source,
    required this.maskable,
  });

  /// The loaded icon as an [Uint8List].
  Uint8List image;

  /// The dominant color of the icon. Will be null if no color could be extracted.
  int? color;

  /// The source of the icon.
  IconSource source;

  /// True if the icon represents as full-bleed icon that can be cropped to other shapes.
  bool maskable;

  Object encode() {
    return <Object?>[
      image,
      color,
      source,
      maskable,
    ];
  }

  static IconResult decode(Object result) {
    result as List<Object?>;
    return IconResult(
      image: result[0]! as Uint8List,
      color: result[1] as int?,
      source: result[2]! as IconSource,
      maskable: result[3]! as bool,
    );
  }
}

class CookiePartitionKey {
  CookiePartitionKey({
    required this.topLevelSite,
  });

  String topLevelSite;

  Object encode() {
    return <Object?>[
      topLevelSite,
    ];
  }

  static CookiePartitionKey decode(Object result) {
    result as List<Object?>;
    return CookiePartitionKey(
      topLevelSite: result[0]! as String,
    );
  }
}

class Cookie {
  Cookie({
    required this.domain,
    this.expirationDate,
    required this.firstPartyDomain,
    required this.hostOnly,
    required this.httpOnly,
    required this.name,
    this.partitionKey,
    required this.path,
    required this.secure,
    required this.session,
    required this.sameSite,
    required this.storeId,
    required this.value,
  });

  String domain;

  int? expirationDate;

  String firstPartyDomain;

  bool hostOnly;

  bool httpOnly;

  String name;

  CookiePartitionKey? partitionKey;

  String path;

  bool secure;

  bool session;

  CookieSameSiteStatus sameSite;

  String storeId;

  String value;

  Object encode() {
    return <Object?>[
      domain,
      expirationDate,
      firstPartyDomain,
      hostOnly,
      httpOnly,
      name,
      partitionKey,
      path,
      secure,
      session,
      sameSite,
      storeId,
      value,
    ];
  }

  static Cookie decode(Object result) {
    result as List<Object?>;
    return Cookie(
      domain: result[0]! as String,
      expirationDate: result[1] as int?,
      firstPartyDomain: result[2]! as String,
      hostOnly: result[3]! as bool,
      httpOnly: result[4]! as bool,
      name: result[5]! as String,
      partitionKey: result[6] as CookiePartitionKey?,
      path: result[7]! as String,
      secure: result[8]! as bool,
      session: result[9]! as bool,
      sameSite: result[10]! as CookieSameSiteStatus,
      storeId: result[11]! as String,
      value: result[12]! as String,
    );
  }
}

class HistoryItem {
  HistoryItem({
    required this.url,
    required this.title,
  });

  String url;

  String title;

  Object encode() {
    return <Object?>[
      url,
      title,
    ];
  }

  static HistoryItem decode(Object result) {
    result as List<Object?>;
    return HistoryItem(
      url: result[0]! as String,
      title: result[1]! as String,
    );
  }
}

class HistoryState {
  HistoryState({
    required this.items,
    required this.currentIndex,
    required this.canGoBack,
    required this.canGoForward,
  });

  List<HistoryItem?> items;

  int currentIndex;

  bool canGoBack;

  bool canGoForward;

  Object encode() {
    return <Object?>[
      items,
      currentIndex,
      canGoBack,
      canGoForward,
    ];
  }

  static HistoryState decode(Object result) {
    result as List<Object?>;
    return HistoryState(
      items: (result[0] as List<Object?>?)!.cast<HistoryItem?>(),
      currentIndex: result[1]! as int,
      canGoBack: result[2]! as bool,
      canGoForward: result[3]! as bool,
    );
  }
}

class ReaderableState {
  ReaderableState({
    required this.readerable,
    required this.active,
  });

  /// Whether or not the current page can be transformed to
  /// be displayed in a reader view.
  bool readerable;

  /// Whether or not reader view is active.
  bool active;

  Object encode() {
    return <Object?>[
      readerable,
      active,
    ];
  }

  static ReaderableState decode(Object result) {
    result as List<Object?>;
    return ReaderableState(
      readerable: result[0]! as bool,
      active: result[1]! as bool,
    );
  }
}

class SecurityInfoState {
  SecurityInfoState({
    required this.secure,
    required this.host,
    required this.issuer,
  });

  bool secure;

  String host;

  String issuer;

  Object encode() {
    return <Object?>[
      secure,
      host,
      issuer,
    ];
  }

  static SecurityInfoState decode(Object result) {
    result as List<Object?>;
    return SecurityInfoState(
      secure: result[0]! as bool,
      host: result[1]! as String,
      issuer: result[2]! as String,
    );
  }
}

class TabContentState {
  TabContentState({
    required this.id,
    this.contextId,
    required this.url,
    required this.title,
    required this.progress,
    required this.isPrivate,
    required this.isFullScreen,
    required this.isLoading,
  });

  String id;

  String? contextId;

  String url;

  String title;

  int progress;

  bool isPrivate;

  bool isFullScreen;

  bool isLoading;

  Object encode() {
    return <Object?>[
      id,
      contextId,
      url,
      title,
      progress,
      isPrivate,
      isFullScreen,
      isLoading,
    ];
  }

  static TabContentState decode(Object result) {
    result as List<Object?>;
    return TabContentState(
      id: result[0]! as String,
      contextId: result[1] as String?,
      url: result[2]! as String,
      title: result[3]! as String,
      progress: result[4]! as int,
      isPrivate: result[5]! as bool,
      isFullScreen: result[6]! as bool,
      isLoading: result[7]! as bool,
    );
  }
}


class _PigeonCodec extends StandardMessageCodec {
  const _PigeonCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is int) {
      buffer.putUint8(4);
      buffer.putInt64(value);
    }    else if (value is RestoreLocation) {
      buffer.putUint8(129);
      writeValue(buffer, value.index);
    }    else if (value is IconType) {
      buffer.putUint8(130);
      writeValue(buffer, value.index);
    }    else if (value is IconSize) {
      buffer.putUint8(131);
      writeValue(buffer, value.index);
    }    else if (value is IconSource) {
      buffer.putUint8(132);
      writeValue(buffer, value.index);
    }    else if (value is CookieSameSiteStatus) {
      buffer.putUint8(133);
      writeValue(buffer, value.index);
    }    else if (value is TranslationOptions) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    }    else if (value is ReaderState) {
      buffer.putUint8(135);
      writeValue(buffer, value.encode());
    }    else if (value is LastMediaAccessState) {
      buffer.putUint8(136);
      writeValue(buffer, value.encode());
    }    else if (value is HistoryMetadataKey) {
      buffer.putUint8(137);
      writeValue(buffer, value.encode());
    }    else if (value is PackageCategoryValue) {
      buffer.putUint8(138);
      writeValue(buffer, value.encode());
    }    else if (value is ExternalPackage) {
      buffer.putUint8(139);
      writeValue(buffer, value.encode());
    }    else if (value is LoadUrlFlagsValue) {
      buffer.putUint8(140);
      writeValue(buffer, value.encode());
    }    else if (value is SourceValue) {
      buffer.putUint8(141);
      writeValue(buffer, value.encode());
    }    else if (value is TabState) {
      buffer.putUint8(142);
      writeValue(buffer, value.encode());
    }    else if (value is RecoverableTab) {
      buffer.putUint8(143);
      writeValue(buffer, value.encode());
    }    else if (value is RecoverableBrowserState) {
      buffer.putUint8(144);
      writeValue(buffer, value.encode());
    }    else if (value is IconRequest) {
      buffer.putUint8(145);
      writeValue(buffer, value.encode());
    }    else if (value is ResourceSize) {
      buffer.putUint8(146);
      writeValue(buffer, value.encode());
    }    else if (value is Resource) {
      buffer.putUint8(147);
      writeValue(buffer, value.encode());
    }    else if (value is IconResult) {
      buffer.putUint8(148);
      writeValue(buffer, value.encode());
    }    else if (value is CookiePartitionKey) {
      buffer.putUint8(149);
      writeValue(buffer, value.encode());
    }    else if (value is Cookie) {
      buffer.putUint8(150);
      writeValue(buffer, value.encode());
    }    else if (value is HistoryItem) {
      buffer.putUint8(151);
      writeValue(buffer, value.encode());
    }    else if (value is HistoryState) {
      buffer.putUint8(152);
      writeValue(buffer, value.encode());
    }    else if (value is ReaderableState) {
      buffer.putUint8(153);
      writeValue(buffer, value.encode());
    }    else if (value is SecurityInfoState) {
      buffer.putUint8(154);
      writeValue(buffer, value.encode());
    }    else if (value is TabContentState) {
      buffer.putUint8(155);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 129: 
        final int? value = readValue(buffer) as int?;
        return value == null ? null : RestoreLocation.values[value];
      case 130: 
        final int? value = readValue(buffer) as int?;
        return value == null ? null : IconType.values[value];
      case 131: 
        final int? value = readValue(buffer) as int?;
        return value == null ? null : IconSize.values[value];
      case 132: 
        final int? value = readValue(buffer) as int?;
        return value == null ? null : IconSource.values[value];
      case 133: 
        final int? value = readValue(buffer) as int?;
        return value == null ? null : CookieSameSiteStatus.values[value];
      case 134: 
        return TranslationOptions.decode(readValue(buffer)!);
      case 135: 
        return ReaderState.decode(readValue(buffer)!);
      case 136: 
        return LastMediaAccessState.decode(readValue(buffer)!);
      case 137: 
        return HistoryMetadataKey.decode(readValue(buffer)!);
      case 138: 
        return PackageCategoryValue.decode(readValue(buffer)!);
      case 139: 
        return ExternalPackage.decode(readValue(buffer)!);
      case 140: 
        return LoadUrlFlagsValue.decode(readValue(buffer)!);
      case 141: 
        return SourceValue.decode(readValue(buffer)!);
      case 142: 
        return TabState.decode(readValue(buffer)!);
      case 143: 
        return RecoverableTab.decode(readValue(buffer)!);
      case 144: 
        return RecoverableBrowserState.decode(readValue(buffer)!);
      case 145: 
        return IconRequest.decode(readValue(buffer)!);
      case 146: 
        return ResourceSize.decode(readValue(buffer)!);
      case 147: 
        return Resource.decode(readValue(buffer)!);
      case 148: 
        return IconResult.decode(readValue(buffer)!);
      case 149: 
        return CookiePartitionKey.decode(readValue(buffer)!);
      case 150: 
        return Cookie.decode(readValue(buffer)!);
      case 151: 
        return HistoryItem.decode(readValue(buffer)!);
      case 152: 
        return HistoryState.decode(readValue(buffer)!);
      case 153: 
        return ReaderableState.decode(readValue(buffer)!);
      case 154: 
        return SecurityInfoState.decode(readValue(buffer)!);
      case 155: 
        return TabContentState.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class GeckoBrowserApi {
  /// Constructor for [GeckoBrowserApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  GeckoBrowserApi({BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix = messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  Future<void> showNativeFragment() async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoBrowserApi.showNativeFragment$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }
}

class GeckoSessionApi {
  /// Constructor for [GeckoSessionApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  GeckoSessionApi({BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix = messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  Future<void> loadUrl({required String? tabId, required String url, required LoadUrlFlagsValue flags, required Map<String?, String?>? additionalHeaders,}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.loadUrl$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[tabId, url, flags, additionalHeaders]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> loadData({required String? tabId, required String data, required String mimeType, required String encoding,}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.loadData$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[tabId, data, mimeType, encoding]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> reload({required String? tabId, required LoadUrlFlagsValue flags}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.reload$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[tabId, flags]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> stopLoading({required String? tabId}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.stopLoading$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[tabId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> goBack({required String? tabId, required bool userInteraction}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.goBack$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[tabId, userInteraction]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> goForward({required String? tabId, required bool userInteraction}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.goForward$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[tabId, userInteraction]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> goToHistoryIndex({required int index, required String? tabId}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.goToHistoryIndex$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[index, tabId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> requestDesktopSite({required String? tabId, required bool enable}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.requestDesktopSite$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[tabId, enable]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> exitFullscreen({required String? tabId}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.exitFullscreen$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[tabId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> saveToPdf({required String? tabId}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.saveToPdf$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[tabId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> printContent({required String? tabId}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.printContent$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[tabId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> translate({required String? tabId, required String fromLanguage, required String toLanguage, required TranslationOptions? options,}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.translate$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[tabId, fromLanguage, toLanguage, options]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> translateRestore({required String? tabId}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.translateRestore$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[tabId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> crashRecovery({required List<String?>? tabIds}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.crashRecovery$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[tabIds]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> purgeHistory() async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.purgeHistory$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> updateLastAccess({required String? tabId, required int? lastAccess}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.updateLastAccess$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[tabId, lastAccess]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }
}

class GeckoTabsApi {
  /// Constructor for [GeckoTabsApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  GeckoTabsApi({BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix = messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  Future<void> selectTab({required String tabId}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.selectTab$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[tabId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> removeTab({required String tabId}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.removeTab$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[tabId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<String> addTab({required String url, required bool selectTab, required bool startLoading, required String? parentId, required LoadUrlFlagsValue flags, required String? contextId, required SourceValue source, required bool private, required HistoryMetadataKey? historyMetadata, required Map<String?, String?>? additionalHeaders,}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.addTab$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[url, selectTab, startLoading, parentId, flags, contextId, source, private, historyMetadata, additionalHeaders]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as String?)!;
    }
  }

  Future<void> removeAllTabs({required bool recoverable}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.removeAllTabs$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[recoverable]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> removeTabs({required List<String?> ids}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.removeTabs$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[ids]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> removeNormalTabs() async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.removeNormalTabs$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> removePrivateTabs() async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.removePrivateTabs$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> undo() async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.undo$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> restoreTabsByList({required List<RecoverableTab?> tabs, required String? selectTabId, required RestoreLocation restoreLocation,}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.restoreTabsByList$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[tabs, selectTabId, restoreLocation]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> restoreTabsByBrowserState({required RecoverableBrowserState state, required RestoreLocation restoreLocation}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.restoreTabsByBrowserState$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[state, restoreLocation]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Selects an already existing tab with the matching [HistoryMetadataKey] or otherwise
  /// creates a new tab with the given [url].
  Future<String> selectOrAddTabByHistory({required String url, required HistoryMetadataKey historyMetadata}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.selectOrAddTabByHistory$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[url, historyMetadata]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as String?)!;
    }
  }

  /// Selects an already existing tab displaying [url] or otherwise creates a new tab.
  Future<String> selectOrAddTabByUrl({required String url, required bool private, required SourceValue source, required LoadUrlFlagsValue flags, required bool ignoreFragment,}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.selectOrAddTabByUrl$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[url, private, source, flags, ignoreFragment]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as String?)!;
    }
  }

  Future<String> duplicateTab({required String? selectTabId, required bool selectNewTab}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.duplicateTab$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[selectTabId, selectNewTab]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as String?)!;
    }
  }

  Future<void> moveTabs({required List<String?> tabIds, required String targetTabId, required bool placeAfter,}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.moveTabs$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[tabIds, targetTabId, placeAfter]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<String> migratePrivateTabUseCase({required String tabId, required String? alternativeUrl}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.migratePrivateTabUseCase$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[tabId, alternativeUrl]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as String?)!;
    }
  }
}

class GeckoIconsApi {
  /// Constructor for [GeckoIconsApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  GeckoIconsApi({BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix = messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  Future<IconResult> loadIcon(IconRequest request) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoIconsApi.loadIcon$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[request]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as IconResult?)!;
    }
  }
}

class GeckoCookieApi {
  /// Constructor for [GeckoCookieApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  GeckoCookieApi({BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix = messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  Future<Cookie> getCookie(String? firstPartyDomain, String name, CookiePartitionKey? partitionKey, String? storeId, String url) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoCookieApi.getCookie$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[firstPartyDomain, name, partitionKey, storeId, url]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as Cookie?)!;
    }
  }

  Future<List<Cookie?>> getAllCookies(String? domain, String? firstPartyDomain, String? name, CookiePartitionKey? partitionKey, String? storeId, String url) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoCookieApi.getAllCookies$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[domain, firstPartyDomain, name, partitionKey, storeId, url]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as List<Object?>?)!.cast<Cookie?>();
    }
  }

  Future<void> setCookie(String? domain, int? expirationDate, String? firstPartyDomain, bool? httpOnly, String? name, CookiePartitionKey? partitionKey, String? path, CookieSameSiteStatus? sameSite, bool? secure, String? storeId, String url, String? value) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoCookieApi.setCookie$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[domain, expirationDate, firstPartyDomain, httpOnly, name, partitionKey, path, sameSite, secure, storeId, url, value]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> removeCookie(String? firstPartyDomain, String name, CookiePartitionKey? partitionKey, String? storeId, String url) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.flutter_mozilla_components.GeckoCookieApi.removeCookie$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[firstPartyDomain, name, partitionKey, storeId, url]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }
}

abstract class GeckoStateEvents {
  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  void onTabListChange(List<String?> tabIds);

  void onSelectedTabChange(String? id);

  void onTabContentStateChange(TabContentState state);

  void onHistoryStateChange(String id, HistoryState state);

  void onReaderableStateChange(String id, ReaderableState state);

  void onSecurityInfoStateChange(String id, SecurityInfoState state);

  void onIconChange(String id, Uint8List? bytes);

  void onThumbnailChange(String id, Uint8List? bytes);

  static void setUp(GeckoStateEvents? api, {BinaryMessenger? binaryMessenger, String messageChannelSuffix = '',}) {
    messageChannelSuffix = messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
    {
      final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onTabListChange$messageChannelSuffix', pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onTabListChange was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final List<String?>? arg_tabIds = (args[0] as List<Object?>?)?.cast<String?>();
          assert(arg_tabIds != null,
              'Argument for dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onTabListChange was null, expected non-null List<String?>.');
          try {
            api.onTabListChange(arg_tabIds!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          }          catch (e) {
            return wrapResponse(error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onSelectedTabChange$messageChannelSuffix', pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onSelectedTabChange was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_id = (args[0] as String?);
          try {
            api.onSelectedTabChange(arg_id);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          }          catch (e) {
            return wrapResponse(error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onTabContentStateChange$messageChannelSuffix', pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onTabContentStateChange was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final TabContentState? arg_state = (args[0] as TabContentState?);
          assert(arg_state != null,
              'Argument for dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onTabContentStateChange was null, expected non-null TabContentState.');
          try {
            api.onTabContentStateChange(arg_state!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          }          catch (e) {
            return wrapResponse(error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onHistoryStateChange$messageChannelSuffix', pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onHistoryStateChange was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_id = (args[0] as String?);
          assert(arg_id != null,
              'Argument for dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onHistoryStateChange was null, expected non-null String.');
          final HistoryState? arg_state = (args[1] as HistoryState?);
          assert(arg_state != null,
              'Argument for dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onHistoryStateChange was null, expected non-null HistoryState.');
          try {
            api.onHistoryStateChange(arg_id!, arg_state!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          }          catch (e) {
            return wrapResponse(error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onReaderableStateChange$messageChannelSuffix', pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onReaderableStateChange was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_id = (args[0] as String?);
          assert(arg_id != null,
              'Argument for dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onReaderableStateChange was null, expected non-null String.');
          final ReaderableState? arg_state = (args[1] as ReaderableState?);
          assert(arg_state != null,
              'Argument for dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onReaderableStateChange was null, expected non-null ReaderableState.');
          try {
            api.onReaderableStateChange(arg_id!, arg_state!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          }          catch (e) {
            return wrapResponse(error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onSecurityInfoStateChange$messageChannelSuffix', pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onSecurityInfoStateChange was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_id = (args[0] as String?);
          assert(arg_id != null,
              'Argument for dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onSecurityInfoStateChange was null, expected non-null String.');
          final SecurityInfoState? arg_state = (args[1] as SecurityInfoState?);
          assert(arg_state != null,
              'Argument for dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onSecurityInfoStateChange was null, expected non-null SecurityInfoState.');
          try {
            api.onSecurityInfoStateChange(arg_id!, arg_state!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          }          catch (e) {
            return wrapResponse(error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onIconChange$messageChannelSuffix', pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onIconChange was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_id = (args[0] as String?);
          assert(arg_id != null,
              'Argument for dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onIconChange was null, expected non-null String.');
          final Uint8List? arg_bytes = (args[1] as Uint8List?);
          try {
            api.onIconChange(arg_id!, arg_bytes);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          }          catch (e) {
            return wrapResponse(error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onThumbnailChange$messageChannelSuffix', pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onThumbnailChange was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_id = (args[0] as String?);
          assert(arg_id != null,
              'Argument for dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onThumbnailChange was null, expected non-null String.');
          final Uint8List? arg_bytes = (args[1] as Uint8List?);
          try {
            api.onThumbnailChange(arg_id!, arg_bytes);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          }          catch (e) {
            return wrapResponse(error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
  }
}
