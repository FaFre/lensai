// Autogenerated from Pigeon (v22.5.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")

package eu.lensai.flutter_mozilla_components.pigeons

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  return if (exception is FlutterError) {
    listOf(
      exception.code,
      exception.message,
      exception.details
    )
  } else {
    listOf(
      exception.javaClass.simpleName,
      exception.toString(),
      "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  }
}

private fun createConnectionError(channelName: String): FlutterError {
  return FlutterError("channel-error",  "Unable to establish connection on channel: '$channelName'.", "")}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class FlutterError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()

/** Indicates what location the tabs should be restored at */
enum class RestoreLocation(val raw: Int) {
  /** Restore tabs at the beginning of the tab list */
  BEGINNING(0),
  /** Restore tabs at the end of the tab list */
  END(1),
  /** Restore tabs at a specific index in the tab list */
  AT_INDEX(2);

  companion object {
    fun ofRaw(raw: Int): RestoreLocation? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** An icon resource type. */
enum class IconType(val raw: Int) {
  FAVICON(0),
  APPLE_TOUCH_ICON(1),
  FLUID_ICON(2),
  IMAGE_SRC(3),
  OPEN_GRAPH(4),
  TWITTER(5),
  MICROSOFT_TILE(6),
  TIPPY_TOP(7),
  MANIFEST_ICON(8);

  companion object {
    fun ofRaw(raw: Int): IconType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Supported sizes.
 *
 * We are trying to limit the supported sizes in order to optimize our caching strategy.
 */
enum class IconSize(val raw: Int) {
  DEFAULT_SIZE(0),
  LAUNCHER(1),
  LAUNCHER_ADAPTIVE(2);

  companion object {
    fun ofRaw(raw: Int): IconSize? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** The source of an [Icon]. */
enum class IconSource(val raw: Int) {
  /** This icon was generated. */
  GENERATOR(0),
  /** This icon was downloaded. */
  DOWNLOAD(1),
  /** This icon was inlined in the document. */
  INLINE(2),
  /** This icon was loaded from an in-memory cache. */
  MEMORY(3),
  /** This icon was loaded from a disk cache. */
  DISK(4);

  companion object {
    fun ofRaw(raw: Int): IconSource? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class CookieSameSiteStatus(val raw: Int) {
  NO_RESTRICTION(0),
  LAX(1),
  STRICT(2),
  UNSPECIFIED(3);

  companion object {
    fun ofRaw(raw: Int): CookieSameSiteStatus? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Translation options that map to the Gecko Translations Options.
 *
 * @property downloadModel If the necessary models should be downloaded on request. If false, then
 * the translation will not complete and throw an exception if the models are not already available.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class TranslationOptions (
  val downloadModel: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): TranslationOptions {
      val downloadModel = pigeonVar_list[0] as Boolean
      return TranslationOptions(downloadModel)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      downloadModel,
    )
  }
}

/**
 * Value type that represents the state of reader mode/view.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ReaderState (
  /**
   * Whether or not the current page can be transformed to
   * be displayed in a reader view.
   */
  val readerable: Boolean,
  /** Whether or not reader view is active. */
  val active: Boolean,
  /**
   * Whether or not a readerable check is required for the
   * current page.
   */
  val checkRequired: Boolean,
  /**
   * Whether or not a new connection to the reader view
   * content script is required.
   */
  val connectRequired: Boolean,
  /** The base URL of the reader view extension page. */
  val baseUrl: String? = null,
  /** The URL of the page currently displayed in reader view. */
  val activeUrl: String? = null,
  /**
   * The vertical scroll position of the page currently
   * displayed in reader view.
   */
  val scrollY: Long? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): ReaderState {
      val readerable = pigeonVar_list[0] as Boolean
      val active = pigeonVar_list[1] as Boolean
      val checkRequired = pigeonVar_list[2] as Boolean
      val connectRequired = pigeonVar_list[3] as Boolean
      val baseUrl = pigeonVar_list[4] as String?
      val activeUrl = pigeonVar_list[5] as String?
      val scrollY = pigeonVar_list[6] as Long?
      return ReaderState(readerable, active, checkRequired, connectRequired, baseUrl, activeUrl, scrollY)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      readerable,
      active,
      checkRequired,
      connectRequired,
      baseUrl,
      activeUrl,
      scrollY,
    )
  }
}

/**
 * Details about the last playing media in this tab.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class LastMediaAccessState (
  /**
   * [TabContentState.url] when media started playing.
   * This is not the URL of the media but of the page when media started.
   * Defaults to "" (an empty String) if media hasn't started playing.
   * This value is only updated when media starts playing.
   * Can be used as a backup to [mediaSessionActive] for knowing the user is still on the same website
   * on which media was playing before media started playing in another tab.
   */
  val lastMediaUrl: String,
  /**
   * The last time media started playing in the current web document.
   * Defaults to [0] if media hasn't started playing.
   * This value is only updated when media starts playing.
   */
  val lastMediaAccess: Long,
  /**
   * Whether or not the last accessed media is still active.
   * Can be used as a backup to [lastMediaUrl] on websites which allow media to continue playing
   * even when the users accesses another page (with another URL) in that same HTML document.
   */
  val mediaSessionActive: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): LastMediaAccessState {
      val lastMediaUrl = pigeonVar_list[0] as String
      val lastMediaAccess = pigeonVar_list[1] as Long
      val mediaSessionActive = pigeonVar_list[2] as Boolean
      return LastMediaAccessState(lastMediaUrl, lastMediaAccess, mediaSessionActive)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      lastMediaUrl,
      lastMediaAccess,
      mediaSessionActive,
    )
  }
}

/**
 * Represents a set of history metadata values that uniquely identify a record. Note that
 * when recording observations, the same set of values may or may not cause a new record to be
 * created, depending on the de-bouncing logic of the underlying storage i.e. recording history
 * metadata observations with the exact same values may be combined into a single record.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class HistoryMetadataKey (
  /** A url of the page. */
  val url: String,
  /**
   * An optional search term if this record was
   * created as part of a search by the user.
   */
  val searchTerm: String? = null,
  /**
   * An optional url of the parent/referrer if
   * this record was created in response to a user opening
   * a page in a new tab.
   */
  val referrerUrl: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): HistoryMetadataKey {
      val url = pigeonVar_list[0] as String
      val searchTerm = pigeonVar_list[1] as String?
      val referrerUrl = pigeonVar_list[2] as String?
      return HistoryMetadataKey(url, searchTerm, referrerUrl)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      url,
      searchTerm,
      referrerUrl,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PackageCategoryValue (
  val value: Long
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PackageCategoryValue {
      val value = pigeonVar_list[0] as Long
      return PackageCategoryValue(value)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      value,
    )
  }
}

/**
 * Describes an external package.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ExternalPackage (
  /** An Android package id. */
  val packageId: String,
  /** A [PackageCategory] as defined by the application. */
  val category: PackageCategoryValue
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): ExternalPackage {
      val packageId = pigeonVar_list[0] as String
      val category = pigeonVar_list[1] as PackageCategoryValue
      return ExternalPackage(packageId, category)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      packageId,
      category,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class LoadUrlFlagsValue (
  val value: Long
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): LoadUrlFlagsValue {
      val value = pigeonVar_list[0] as Long
      return LoadUrlFlagsValue(value)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      value,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class SourceValue (
  val id: Long,
  val caller: ExternalPackage? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): SourceValue {
      val id = pigeonVar_list[0] as Long
      val caller = pigeonVar_list[1] as ExternalPackage?
      return SourceValue(id, caller)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      id,
      caller,
    )
  }
}

/**
 * A tab that is no longer open and in the list of tabs, but that can be restored (recovered) at
 * any time if it's combined with an [EngineSessionState] to form a [RecoverableTab].
 *
 * The values of this data class are usually filled with the values of a [TabSessionState] when
 * getting closed.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class TabState (
  /** Unique ID identifying this tab. */
  val id: String,
  /** The last URL of this tab. */
  val url: String,
  /**
   * The unique ID of the parent tab if this tab was opened from another tab (e.g. via
   * the context menu).
   */
  val parentId: String? = null,
  /** The last title of this tab (or an empty String). */
  val title: String,
  /**
   * The last used search terms, or an empty string if no
   * search was executed for this session.
   */
  val searchTerm: String,
  /** The context ID ("container") this tab used (or null). */
  val contextId: String? = null,
  /** The last [ReaderState] of the tab. */
  val readerState: ReaderState,
  /** The last time this tab was selected. */
  val lastAccess: Long,
  /** Timestamp of the tab's creation. */
  val createdAt: Long,
  /** Details about the last time was playing in this tab. */
  val lastMediaAccessState: LastMediaAccessState,
  /** If tab was private. */
  val private: Boolean,
  /** The last [HistoryMetadataKey] of the tab. */
  val historyMetadata: HistoryMetadataKey? = null,
  /** The last [IconSource] of the tab. */
  val source: SourceValue,
  /** The index the tab should be restored at. */
  val index: Long,
  /** Whether the tab has form data. */
  val hasFormData: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): TabState {
      val id = pigeonVar_list[0] as String
      val url = pigeonVar_list[1] as String
      val parentId = pigeonVar_list[2] as String?
      val title = pigeonVar_list[3] as String
      val searchTerm = pigeonVar_list[4] as String
      val contextId = pigeonVar_list[5] as String?
      val readerState = pigeonVar_list[6] as ReaderState
      val lastAccess = pigeonVar_list[7] as Long
      val createdAt = pigeonVar_list[8] as Long
      val lastMediaAccessState = pigeonVar_list[9] as LastMediaAccessState
      val private = pigeonVar_list[10] as Boolean
      val historyMetadata = pigeonVar_list[11] as HistoryMetadataKey?
      val source = pigeonVar_list[12] as SourceValue
      val index = pigeonVar_list[13] as Long
      val hasFormData = pigeonVar_list[14] as Boolean
      return TabState(id, url, parentId, title, searchTerm, contextId, readerState, lastAccess, createdAt, lastMediaAccessState, private, historyMetadata, source, index, hasFormData)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      id,
      url,
      parentId,
      title,
      searchTerm,
      contextId,
      readerState,
      lastAccess,
      createdAt,
      lastMediaAccessState,
      private,
      historyMetadata,
      source,
      index,
      hasFormData,
    )
  }
}

/**
 * A recoverable version of [TabState].
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class RecoverableTab (
  /** The [EngineSessionState] needed for restoring the previous state of this tab. */
  val engineSessionStateJson: String? = null,
  /** A [TabState] instance containing basic tab state. */
  val state: TabState
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): RecoverableTab {
      val engineSessionStateJson = pigeonVar_list[0] as String?
      val state = pigeonVar_list[1] as TabState
      return RecoverableTab(engineSessionStateJson, state)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      engineSessionStateJson,
      state,
    )
  }
}

/**
 * A restored browser state, read from disk.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class RecoverableBrowserState (
  /** The list of restored tabs. */
  val tabs: List<RecoverableTab?>,
  /** The ID of the selected tab in [tabs]. Or `null` if no selection was restored. */
  val selectedTabId: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): RecoverableBrowserState {
      val tabs = pigeonVar_list[0] as List<RecoverableTab?>
      val selectedTabId = pigeonVar_list[1] as String?
      return RecoverableBrowserState(tabs, selectedTabId)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      tabs,
      selectedTabId,
    )
  }
}

/**
 * A request to load an [Icon].
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class IconRequest (
  val url: String,
  val size: IconSize,
  val resources: List<Resource?>,
  val color: Long? = null,
  val isPrivate: Boolean,
  val waitOnNetworkLoad: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): IconRequest {
      val url = pigeonVar_list[0] as String
      val size = pigeonVar_list[1] as IconSize
      val resources = pigeonVar_list[2] as List<Resource?>
      val color = pigeonVar_list[3] as Long?
      val isPrivate = pigeonVar_list[4] as Boolean
      val waitOnNetworkLoad = pigeonVar_list[5] as Boolean
      return IconRequest(url, size, resources, color, isPrivate, waitOnNetworkLoad)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      url,
      size,
      resources,
      color,
      isPrivate,
      waitOnNetworkLoad,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class ResourceSize (
  val height: Long,
  val width: Long
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): ResourceSize {
      val height = pigeonVar_list[0] as Long
      val width = pigeonVar_list[1] as Long
      return ResourceSize(height, width)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      height,
      width,
    )
  }
}

/**
 * An icon resource that can be loaded.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class Resource (
  val url: String,
  val type: IconType,
  val sizes: List<ResourceSize?>,
  val mimeType: String? = null,
  val maskable: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): Resource {
      val url = pigeonVar_list[0] as String
      val type = pigeonVar_list[1] as IconType
      val sizes = pigeonVar_list[2] as List<ResourceSize?>
      val mimeType = pigeonVar_list[3] as String?
      val maskable = pigeonVar_list[4] as Boolean
      return Resource(url, type, sizes, mimeType, maskable)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      url,
      type,
      sizes,
      mimeType,
      maskable,
    )
  }
}

/**
 * An [Icon] returned by [BrowserIcons] after processing an [IconRequest]
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class IconResult (
  /** The loaded icon as an [Uint8List]. */
  val image: ByteArray,
  /** The dominant color of the icon. Will be null if no color could be extracted. */
  val color: Long? = null,
  /** The source of the icon. */
  val source: IconSource,
  /** True if the icon represents as full-bleed icon that can be cropped to other shapes. */
  val maskable: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): IconResult {
      val image = pigeonVar_list[0] as ByteArray
      val color = pigeonVar_list[1] as Long?
      val source = pigeonVar_list[2] as IconSource
      val maskable = pigeonVar_list[3] as Boolean
      return IconResult(image, color, source, maskable)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      image,
      color,
      source,
      maskable,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class CookiePartitionKey (
  val topLevelSite: String
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): CookiePartitionKey {
      val topLevelSite = pigeonVar_list[0] as String
      return CookiePartitionKey(topLevelSite)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      topLevelSite,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class Cookie (
  val domain: String,
  val expirationDate: Long? = null,
  val firstPartyDomain: String,
  val hostOnly: Boolean,
  val httpOnly: Boolean,
  val name: String,
  val partitionKey: CookiePartitionKey? = null,
  val path: String,
  val secure: Boolean,
  val session: Boolean,
  val sameSite: CookieSameSiteStatus,
  val storeId: String,
  val value: String
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): Cookie {
      val domain = pigeonVar_list[0] as String
      val expirationDate = pigeonVar_list[1] as Long?
      val firstPartyDomain = pigeonVar_list[2] as String
      val hostOnly = pigeonVar_list[3] as Boolean
      val httpOnly = pigeonVar_list[4] as Boolean
      val name = pigeonVar_list[5] as String
      val partitionKey = pigeonVar_list[6] as CookiePartitionKey?
      val path = pigeonVar_list[7] as String
      val secure = pigeonVar_list[8] as Boolean
      val session = pigeonVar_list[9] as Boolean
      val sameSite = pigeonVar_list[10] as CookieSameSiteStatus
      val storeId = pigeonVar_list[11] as String
      val value = pigeonVar_list[12] as String
      return Cookie(domain, expirationDate, firstPartyDomain, hostOnly, httpOnly, name, partitionKey, path, secure, session, sameSite, storeId, value)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      domain,
      expirationDate,
      firstPartyDomain,
      hostOnly,
      httpOnly,
      name,
      partitionKey,
      path,
      secure,
      session,
      sameSite,
      storeId,
      value,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class HistoryItem (
  val url: String,
  val title: String
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): HistoryItem {
      val url = pigeonVar_list[0] as String
      val title = pigeonVar_list[1] as String
      return HistoryItem(url, title)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      url,
      title,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class HistoryState (
  val items: List<HistoryItem?>,
  val currentIndex: Long,
  val canGoBack: Boolean,
  val canGoForward: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): HistoryState {
      val items = pigeonVar_list[0] as List<HistoryItem?>
      val currentIndex = pigeonVar_list[1] as Long
      val canGoBack = pigeonVar_list[2] as Boolean
      val canGoForward = pigeonVar_list[3] as Boolean
      return HistoryState(items, currentIndex, canGoBack, canGoForward)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      items,
      currentIndex,
      canGoBack,
      canGoForward,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class ReaderableState (
  /**
   * Whether or not the current page can be transformed to
   * be displayed in a reader view.
   */
  val readerable: Boolean,
  /** Whether or not reader view is active. */
  val active: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): ReaderableState {
      val readerable = pigeonVar_list[0] as Boolean
      val active = pigeonVar_list[1] as Boolean
      return ReaderableState(readerable, active)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      readerable,
      active,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class SecurityInfoState (
  val secure: Boolean,
  val host: String,
  val issuer: String
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): SecurityInfoState {
      val secure = pigeonVar_list[0] as Boolean
      val host = pigeonVar_list[1] as String
      val issuer = pigeonVar_list[2] as String
      return SecurityInfoState(secure, host, issuer)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      secure,
      host,
      issuer,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class TabContentState (
  val id: String,
  val contextId: String? = null,
  val url: String,
  val title: String,
  val progress: Long,
  val isPrivate: Boolean,
  val isFullScreen: Boolean,
  val isLoading: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): TabContentState {
      val id = pigeonVar_list[0] as String
      val contextId = pigeonVar_list[1] as String?
      val url = pigeonVar_list[2] as String
      val title = pigeonVar_list[3] as String
      val progress = pigeonVar_list[4] as Long
      val isPrivate = pigeonVar_list[5] as Boolean
      val isFullScreen = pigeonVar_list[6] as Boolean
      val isLoading = pigeonVar_list[7] as Boolean
      return TabContentState(id, contextId, url, title, progress, isPrivate, isFullScreen, isLoading)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      id,
      contextId,
      url,
      title,
      progress,
      isPrivate,
      isFullScreen,
      isLoading,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class FindResultState (
  val activeMatchOrdinal: Long,
  val numberOfMatches: Long,
  val isDoneCounting: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): FindResultState {
      val activeMatchOrdinal = pigeonVar_list[0] as Long
      val numberOfMatches = pigeonVar_list[1] as Long
      val isDoneCounting = pigeonVar_list[2] as Boolean
      return FindResultState(activeMatchOrdinal, numberOfMatches, isDoneCounting)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      activeMatchOrdinal,
      numberOfMatches,
      isDoneCounting,
    )
  }
}
private open class GeckoPigeonCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      129.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          RestoreLocation.ofRaw(it.toInt())
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          IconType.ofRaw(it.toInt())
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          IconSize.ofRaw(it.toInt())
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          IconSource.ofRaw(it.toInt())
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          CookieSameSiteStatus.ofRaw(it.toInt())
        }
      }
      134.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TranslationOptions.fromList(it)
        }
      }
      135.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ReaderState.fromList(it)
        }
      }
      136.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          LastMediaAccessState.fromList(it)
        }
      }
      137.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          HistoryMetadataKey.fromList(it)
        }
      }
      138.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PackageCategoryValue.fromList(it)
        }
      }
      139.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ExternalPackage.fromList(it)
        }
      }
      140.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          LoadUrlFlagsValue.fromList(it)
        }
      }
      141.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          SourceValue.fromList(it)
        }
      }
      142.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TabState.fromList(it)
        }
      }
      143.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RecoverableTab.fromList(it)
        }
      }
      144.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RecoverableBrowserState.fromList(it)
        }
      }
      145.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          IconRequest.fromList(it)
        }
      }
      146.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ResourceSize.fromList(it)
        }
      }
      147.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          Resource.fromList(it)
        }
      }
      148.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          IconResult.fromList(it)
        }
      }
      149.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CookiePartitionKey.fromList(it)
        }
      }
      150.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          Cookie.fromList(it)
        }
      }
      151.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          HistoryItem.fromList(it)
        }
      }
      152.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          HistoryState.fromList(it)
        }
      }
      153.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ReaderableState.fromList(it)
        }
      }
      154.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          SecurityInfoState.fromList(it)
        }
      }
      155.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TabContentState.fromList(it)
        }
      }
      156.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          FindResultState.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is RestoreLocation -> {
        stream.write(129)
        writeValue(stream, value.raw)
      }
      is IconType -> {
        stream.write(130)
        writeValue(stream, value.raw)
      }
      is IconSize -> {
        stream.write(131)
        writeValue(stream, value.raw)
      }
      is IconSource -> {
        stream.write(132)
        writeValue(stream, value.raw)
      }
      is CookieSameSiteStatus -> {
        stream.write(133)
        writeValue(stream, value.raw)
      }
      is TranslationOptions -> {
        stream.write(134)
        writeValue(stream, value.toList())
      }
      is ReaderState -> {
        stream.write(135)
        writeValue(stream, value.toList())
      }
      is LastMediaAccessState -> {
        stream.write(136)
        writeValue(stream, value.toList())
      }
      is HistoryMetadataKey -> {
        stream.write(137)
        writeValue(stream, value.toList())
      }
      is PackageCategoryValue -> {
        stream.write(138)
        writeValue(stream, value.toList())
      }
      is ExternalPackage -> {
        stream.write(139)
        writeValue(stream, value.toList())
      }
      is LoadUrlFlagsValue -> {
        stream.write(140)
        writeValue(stream, value.toList())
      }
      is SourceValue -> {
        stream.write(141)
        writeValue(stream, value.toList())
      }
      is TabState -> {
        stream.write(142)
        writeValue(stream, value.toList())
      }
      is RecoverableTab -> {
        stream.write(143)
        writeValue(stream, value.toList())
      }
      is RecoverableBrowserState -> {
        stream.write(144)
        writeValue(stream, value.toList())
      }
      is IconRequest -> {
        stream.write(145)
        writeValue(stream, value.toList())
      }
      is ResourceSize -> {
        stream.write(146)
        writeValue(stream, value.toList())
      }
      is Resource -> {
        stream.write(147)
        writeValue(stream, value.toList())
      }
      is IconResult -> {
        stream.write(148)
        writeValue(stream, value.toList())
      }
      is CookiePartitionKey -> {
        stream.write(149)
        writeValue(stream, value.toList())
      }
      is Cookie -> {
        stream.write(150)
        writeValue(stream, value.toList())
      }
      is HistoryItem -> {
        stream.write(151)
        writeValue(stream, value.toList())
      }
      is HistoryState -> {
        stream.write(152)
        writeValue(stream, value.toList())
      }
      is ReaderableState -> {
        stream.write(153)
        writeValue(stream, value.toList())
      }
      is SecurityInfoState -> {
        stream.write(154)
        writeValue(stream, value.toList())
      }
      is TabContentState -> {
        stream.write(155)
        writeValue(stream, value.toList())
      }
      is FindResultState -> {
        stream.write(156)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}


/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GeckoBrowserApi {
  fun showNativeFragment()

  companion object {
    /** The codec used by GeckoBrowserApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoBrowserApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoBrowserApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoBrowserApi.showNativeFragment$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.showNativeFragment()
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GeckoEngineSettingsApi {
  fun javaScriptEnabled(state: Boolean)

  companion object {
    /** The codec used by GeckoEngineSettingsApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoEngineSettingsApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoEngineSettingsApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoEngineSettingsApi.javaScriptEnabled$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val stateArg = args[0] as Boolean
            val wrapped: List<Any?> = try {
              api.javaScriptEnabled(stateArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GeckoSessionApi {
  fun loadUrl(tabId: String?, url: String, flags: LoadUrlFlagsValue, additionalHeaders: Map<String, String>?)
  fun loadData(tabId: String?, data: String, mimeType: String, encoding: String)
  fun reload(tabId: String?, flags: LoadUrlFlagsValue)
  fun stopLoading(tabId: String?)
  fun goBack(tabId: String?, userInteraction: Boolean)
  fun goForward(tabId: String?, userInteraction: Boolean)
  fun goToHistoryIndex(index: Long, tabId: String?)
  fun requestDesktopSite(tabId: String?, enable: Boolean)
  fun exitFullscreen(tabId: String?)
  fun saveToPdf(tabId: String?)
  fun printContent(tabId: String?)
  fun translate(tabId: String?, fromLanguage: String, toLanguage: String, options: TranslationOptions?)
  fun translateRestore(tabId: String?)
  fun crashRecovery(tabIds: List<String>?)
  fun purgeHistory()
  fun updateLastAccess(tabId: String?, lastAccess: Long?)
  fun requestScreenshot(callback: (Result<ByteArray?>) -> Unit)

  companion object {
    /** The codec used by GeckoSessionApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoSessionApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoSessionApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.loadUrl$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val urlArg = args[1] as String
            val flagsArg = args[2] as LoadUrlFlagsValue
            val additionalHeadersArg = args[3] as Map<String, String>?
            val wrapped: List<Any?> = try {
              api.loadUrl(tabIdArg, urlArg, flagsArg, additionalHeadersArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.loadData$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val dataArg = args[1] as String
            val mimeTypeArg = args[2] as String
            val encodingArg = args[3] as String
            val wrapped: List<Any?> = try {
              api.loadData(tabIdArg, dataArg, mimeTypeArg, encodingArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.reload$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val flagsArg = args[1] as LoadUrlFlagsValue
            val wrapped: List<Any?> = try {
              api.reload(tabIdArg, flagsArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.stopLoading$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val wrapped: List<Any?> = try {
              api.stopLoading(tabIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.goBack$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val userInteractionArg = args[1] as Boolean
            val wrapped: List<Any?> = try {
              api.goBack(tabIdArg, userInteractionArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.goForward$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val userInteractionArg = args[1] as Boolean
            val wrapped: List<Any?> = try {
              api.goForward(tabIdArg, userInteractionArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.goToHistoryIndex$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val indexArg = args[0] as Long
            val tabIdArg = args[1] as String?
            val wrapped: List<Any?> = try {
              api.goToHistoryIndex(indexArg, tabIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.requestDesktopSite$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val enableArg = args[1] as Boolean
            val wrapped: List<Any?> = try {
              api.requestDesktopSite(tabIdArg, enableArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.exitFullscreen$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val wrapped: List<Any?> = try {
              api.exitFullscreen(tabIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.saveToPdf$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val wrapped: List<Any?> = try {
              api.saveToPdf(tabIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.printContent$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val wrapped: List<Any?> = try {
              api.printContent(tabIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.translate$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val fromLanguageArg = args[1] as String
            val toLanguageArg = args[2] as String
            val optionsArg = args[3] as TranslationOptions?
            val wrapped: List<Any?> = try {
              api.translate(tabIdArg, fromLanguageArg, toLanguageArg, optionsArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.translateRestore$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val wrapped: List<Any?> = try {
              api.translateRestore(tabIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.crashRecovery$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdsArg = args[0] as List<String>?
            val wrapped: List<Any?> = try {
              api.crashRecovery(tabIdsArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.purgeHistory$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.purgeHistory()
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.updateLastAccess$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val lastAccessArg = args[1] as Long?
            val wrapped: List<Any?> = try {
              api.updateLastAccess(tabIdArg, lastAccessArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.requestScreenshot$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.requestScreenshot{ result: Result<ByteArray?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GeckoTabsApi {
  fun syncEvents(onSelectedTabChange: Boolean, onTabListChange: Boolean, onTabContentStateChange: Boolean, onIconChange: Boolean, onSecurityInfoStateChange: Boolean, onReaderableStateChange: Boolean, onHistoryStateChange: Boolean, onFindResults: Boolean, onThumbnailChange: Boolean)
  fun selectTab(tabId: String)
  fun removeTab(tabId: String)
  fun addTab(url: String, selectTab: Boolean, startLoading: Boolean, parentId: String?, flags: LoadUrlFlagsValue, contextId: String?, source: SourceValue, private: Boolean, historyMetadata: HistoryMetadataKey?, additionalHeaders: Map<String, String>?): String
  fun removeAllTabs(recoverable: Boolean)
  fun removeTabs(ids: List<String>)
  fun removeNormalTabs()
  fun removePrivateTabs()
  fun undo()
  fun restoreTabsByList(tabs: List<RecoverableTab>, selectTabId: String?, restoreLocation: RestoreLocation)
  fun restoreTabsByBrowserState(state: RecoverableBrowserState, restoreLocation: RestoreLocation)
  /**
   * Selects an already existing tab with the matching [HistoryMetadataKey] or otherwise
   * creates a new tab with the given [url].
   */
  fun selectOrAddTabByHistory(url: String, historyMetadata: HistoryMetadataKey): String
  /** Selects an already existing tab displaying [url] or otherwise creates a new tab. */
  fun selectOrAddTabByUrl(url: String, private: Boolean, source: SourceValue, flags: LoadUrlFlagsValue, ignoreFragment: Boolean): String
  fun duplicateTab(selectTabId: String?, selectNewTab: Boolean): String
  fun moveTabs(tabIds: List<String>, targetTabId: String, placeAfter: Boolean)
  fun migratePrivateTabUseCase(tabId: String, alternativeUrl: String?): String

  companion object {
    /** The codec used by GeckoTabsApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoTabsApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoTabsApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.syncEvents$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val onSelectedTabChangeArg = args[0] as Boolean
            val onTabListChangeArg = args[1] as Boolean
            val onTabContentStateChangeArg = args[2] as Boolean
            val onIconChangeArg = args[3] as Boolean
            val onSecurityInfoStateChangeArg = args[4] as Boolean
            val onReaderableStateChangeArg = args[5] as Boolean
            val onHistoryStateChangeArg = args[6] as Boolean
            val onFindResultsArg = args[7] as Boolean
            val onThumbnailChangeArg = args[8] as Boolean
            val wrapped: List<Any?> = try {
              api.syncEvents(onSelectedTabChangeArg, onTabListChangeArg, onTabContentStateChangeArg, onIconChangeArg, onSecurityInfoStateChangeArg, onReaderableStateChangeArg, onHistoryStateChangeArg, onFindResultsArg, onThumbnailChangeArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.selectTab$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              api.selectTab(tabIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.removeTab$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              api.removeTab(tabIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.addTab$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val urlArg = args[0] as String
            val selectTabArg = args[1] as Boolean
            val startLoadingArg = args[2] as Boolean
            val parentIdArg = args[3] as String?
            val flagsArg = args[4] as LoadUrlFlagsValue
            val contextIdArg = args[5] as String?
            val sourceArg = args[6] as SourceValue
            val privateArg = args[7] as Boolean
            val historyMetadataArg = args[8] as HistoryMetadataKey?
            val additionalHeadersArg = args[9] as Map<String, String>?
            val wrapped: List<Any?> = try {
              listOf(api.addTab(urlArg, selectTabArg, startLoadingArg, parentIdArg, flagsArg, contextIdArg, sourceArg, privateArg, historyMetadataArg, additionalHeadersArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.removeAllTabs$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val recoverableArg = args[0] as Boolean
            val wrapped: List<Any?> = try {
              api.removeAllTabs(recoverableArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.removeTabs$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val idsArg = args[0] as List<String>
            val wrapped: List<Any?> = try {
              api.removeTabs(idsArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.removeNormalTabs$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.removeNormalTabs()
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.removePrivateTabs$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.removePrivateTabs()
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.undo$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.undo()
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.restoreTabsByList$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabsArg = args[0] as List<RecoverableTab>
            val selectTabIdArg = args[1] as String?
            val restoreLocationArg = args[2] as RestoreLocation
            val wrapped: List<Any?> = try {
              api.restoreTabsByList(tabsArg, selectTabIdArg, restoreLocationArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.restoreTabsByBrowserState$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val stateArg = args[0] as RecoverableBrowserState
            val restoreLocationArg = args[1] as RestoreLocation
            val wrapped: List<Any?> = try {
              api.restoreTabsByBrowserState(stateArg, restoreLocationArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.selectOrAddTabByHistory$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val urlArg = args[0] as String
            val historyMetadataArg = args[1] as HistoryMetadataKey
            val wrapped: List<Any?> = try {
              listOf(api.selectOrAddTabByHistory(urlArg, historyMetadataArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.selectOrAddTabByUrl$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val urlArg = args[0] as String
            val privateArg = args[1] as Boolean
            val sourceArg = args[2] as SourceValue
            val flagsArg = args[3] as LoadUrlFlagsValue
            val ignoreFragmentArg = args[4] as Boolean
            val wrapped: List<Any?> = try {
              listOf(api.selectOrAddTabByUrl(urlArg, privateArg, sourceArg, flagsArg, ignoreFragmentArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.duplicateTab$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val selectTabIdArg = args[0] as String?
            val selectNewTabArg = args[1] as Boolean
            val wrapped: List<Any?> = try {
              listOf(api.duplicateTab(selectTabIdArg, selectNewTabArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.moveTabs$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdsArg = args[0] as List<String>
            val targetTabIdArg = args[1] as String
            val placeAfterArg = args[2] as Boolean
            val wrapped: List<Any?> = try {
              api.moveTabs(tabIdsArg, targetTabIdArg, placeAfterArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.migratePrivateTabUseCase$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String
            val alternativeUrlArg = args[1] as String?
            val wrapped: List<Any?> = try {
              listOf(api.migratePrivateTabUseCase(tabIdArg, alternativeUrlArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GeckoFindApi {
  fun findAll(tabId: String?, text: String)
  fun findNext(tabId: String?, forward: Boolean)
  fun clearMatches(tabId: String?)

  companion object {
    /** The codec used by GeckoFindApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoFindApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoFindApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoFindApi.findAll$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val textArg = args[1] as String
            val wrapped: List<Any?> = try {
              api.findAll(tabIdArg, textArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoFindApi.findNext$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val forwardArg = args[1] as Boolean
            val wrapped: List<Any?> = try {
              api.findNext(tabIdArg, forwardArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoFindApi.clearMatches$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val wrapped: List<Any?> = try {
              api.clearMatches(tabIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GeckoIconsApi {
  fun loadIcon(request: IconRequest, callback: (Result<IconResult>) -> Unit)

  companion object {
    /** The codec used by GeckoIconsApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoIconsApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoIconsApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoIconsApi.loadIcon$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val requestArg = args[0] as IconRequest
            api.loadIcon(requestArg) { result: Result<IconResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GeckoCookieApi {
  fun getCookie(firstPartyDomain: String?, name: String, partitionKey: CookiePartitionKey?, storeId: String?, url: String, callback: (Result<Cookie>) -> Unit)
  fun getAllCookies(domain: String?, firstPartyDomain: String?, name: String?, partitionKey: CookiePartitionKey?, storeId: String?, url: String, callback: (Result<List<Cookie>>) -> Unit)
  fun setCookie(domain: String?, expirationDate: Long?, firstPartyDomain: String?, httpOnly: Boolean?, name: String?, partitionKey: CookiePartitionKey?, path: String?, sameSite: CookieSameSiteStatus?, secure: Boolean?, storeId: String?, url: String, value: String?, callback: (Result<Unit>) -> Unit)
  fun removeCookie(firstPartyDomain: String?, name: String, partitionKey: CookiePartitionKey?, storeId: String?, url: String, callback: (Result<Unit>) -> Unit)

  companion object {
    /** The codec used by GeckoCookieApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoCookieApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoCookieApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoCookieApi.getCookie$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val firstPartyDomainArg = args[0] as String?
            val nameArg = args[1] as String
            val partitionKeyArg = args[2] as CookiePartitionKey?
            val storeIdArg = args[3] as String?
            val urlArg = args[4] as String
            api.getCookie(firstPartyDomainArg, nameArg, partitionKeyArg, storeIdArg, urlArg) { result: Result<Cookie> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoCookieApi.getAllCookies$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val domainArg = args[0] as String?
            val firstPartyDomainArg = args[1] as String?
            val nameArg = args[2] as String?
            val partitionKeyArg = args[3] as CookiePartitionKey?
            val storeIdArg = args[4] as String?
            val urlArg = args[5] as String
            api.getAllCookies(domainArg, firstPartyDomainArg, nameArg, partitionKeyArg, storeIdArg, urlArg) { result: Result<List<Cookie>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoCookieApi.setCookie$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val domainArg = args[0] as String?
            val expirationDateArg = args[1] as Long?
            val firstPartyDomainArg = args[2] as String?
            val httpOnlyArg = args[3] as Boolean?
            val nameArg = args[4] as String?
            val partitionKeyArg = args[5] as CookiePartitionKey?
            val pathArg = args[6] as String?
            val sameSiteArg = args[7] as CookieSameSiteStatus?
            val secureArg = args[8] as Boolean?
            val storeIdArg = args[9] as String?
            val urlArg = args[10] as String
            val valueArg = args[11] as String?
            api.setCookie(domainArg, expirationDateArg, firstPartyDomainArg, httpOnlyArg, nameArg, partitionKeyArg, pathArg, sameSiteArg, secureArg, storeIdArg, urlArg, valueArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoCookieApi.removeCookie$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val firstPartyDomainArg = args[0] as String?
            val nameArg = args[1] as String
            val partitionKeyArg = args[2] as CookiePartitionKey?
            val storeIdArg = args[3] as String?
            val urlArg = args[4] as String
            api.removeCookie(firstPartyDomainArg, nameArg, partitionKeyArg, storeIdArg, urlArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class GeckoStateEvents(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by GeckoStateEvents. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
  }
  fun onFragmentReadyStateChange(stateArg: Boolean, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onFragmentReadyStateChange$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(stateArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun onTabListChange(tabIdsArg: List<String>, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onTabListChange$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(tabIdsArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun onSelectedTabChange(idArg: String?, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onSelectedTabChange$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(idArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun onTabContentStateChange(stateArg: TabContentState, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onTabContentStateChange$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(stateArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun onHistoryStateChange(idArg: String, stateArg: HistoryState, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onHistoryStateChange$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(idArg, stateArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun onReaderableStateChange(idArg: String, stateArg: ReaderableState, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onReaderableStateChange$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(idArg, stateArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun onSecurityInfoStateChange(idArg: String, stateArg: SecurityInfoState, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onSecurityInfoStateChange$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(idArg, stateArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun onIconChange(idArg: String, bytesArg: ByteArray?, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onIconChange$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(idArg, bytesArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun onThumbnailChange(idArg: String, bytesArg: ByteArray?, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onThumbnailChange$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(idArg, bytesArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun onFindResults(idArg: String, resultsArg: List<FindResultState>, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onFindResults$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(idArg, resultsArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface ReaderViewEvents {
  fun onToggleReaderView(enable: Boolean)
  fun onAppearanceButtonTap()

  companion object {
    /** The codec used by ReaderViewEvents. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `ReaderViewEvents` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: ReaderViewEvents?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.ReaderViewEvents.onToggleReaderView$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val enableArg = args[0] as Boolean
            val wrapped: List<Any?> = try {
              api.onToggleReaderView(enableArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.ReaderViewEvents.onAppearanceButtonTap$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.onAppearanceButtonTap()
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class ReaderViewController(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by ReaderViewController. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
  }
  fun appearanceButtonVisibility(visibleArg: Boolean, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.ReaderViewController.appearanceButtonVisibility$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(visibleArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class SelectionAction(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by SelectionAction. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
  }
  /**
   * Gets Strings representing all possible selection actions.
   *
   * @returns String IDs for each action that could possibly be shown in the context menu. This
   * array must include all actions, available or not, and must not change over the class lifetime.
   */
  fun getAllActions(callback: (Result<List<String>>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.SelectionAction.getAllActions$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else if (it[0] == null) {
          callback(Result.failure(FlutterError("null-error", "Flutter api returned null value for non-null return value.", "")))
        } else {
          val output = it[0] as List<String>
          callback(Result.success(output))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /**
   * Checks if an action can be shown on a new selection context menu.
   *
   * @returns whether or not the the custom action with the id of [id] is currently available
   *  which may be informed by [selectedText].
   */
  fun isActionAvailable(idArg: String, selectedTextArg: String, callback: (Result<Boolean>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.SelectionAction.isActionAvailable$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(idArg, selectedTextArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else if (it[0] == null) {
          callback(Result.failure(FlutterError("null-error", "Flutter api returned null value for non-null return value.", "")))
        } else {
          val output = it[0] as Boolean
          callback(Result.success(output))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /**
   * Gets a title to be shown in the selection context menu.
   *
   * @returns the text that should be shown on the action.
   */
  fun getActionTitle(idArg: String, callback: (Result<String?>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.SelectionAction.getActionTitle$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(idArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          val output = it[0] as String?
          callback(Result.success(output))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /**
   * Should perform the action with the id of [id].
   *
   * @returns [true] if the action was consumed.
   */
  fun performAction(idArg: String, selectedTextArg: String, callback: (Result<Boolean>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.SelectionAction.performAction$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(idArg, selectedTextArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else if (it[0] == null) {
          callback(Result.failure(FlutterError("null-error", "Flutter api returned null value for non-null return value.", "")))
        } else {
          val output = it[0] as Boolean
          callback(Result.success(output))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /**
   * Takes in a list of actions and sorts them.
   *
   * @returns the sorted list.
   */
  fun sortedActions(actionsArg: List<String>, callback: (Result<List<String>>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.SelectionAction.sortedActions$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(actionsArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else if (it[0] == null) {
          callback(Result.failure(FlutterError("null-error", "Flutter api returned null value for non-null return value.", "")))
        } else {
          val output = it[0] as List<String>
          callback(Result.success(output))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
}
